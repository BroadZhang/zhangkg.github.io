<!DOCTYPE HTML>
<html class="no-js" lang="zh-CN">
<!--
//                            _ooOoo_
//                           o8888888o
//                           88" . "88
//                           (| -_- |)
//                            O\ = /O
//                        ____/`---'\____
//                      .   ' \\| |// `.
//                       / \\||| : |||// \
//                     / _||||| -:- |||||- \
//                       | | \\\ - /// | |
//                     | \_| ''\---/'' | |
//                      \ .-\__ `-` ___/-. /
//                   ___`. .' /--.--\ `. . __
//                ."" '< `.___\_<|>_/___.' >'"".
//               | | : `- \`.;`\ _ /`;.`/ - ` : | |
//                 \ \ `-. \_ __\ /__ _/ .-` / /
//         ======`-.____`-.___\_____/___.-`____.-'======
//                            `=---='
//                 拦截插件累计拦截逗比攻击"1381438"次！
//         .............................................
//                  佛祖保佑             永无BUG
//          佛曰:
//                  写字楼里写字间，写字间里程序员；
//                  程序人员写程序，又拿程序换酒钱。
//                  酒醒只在网上坐，酒醉还来网下眠；
//                  酒醉酒醒日复日，网上网下年复年。
//                  但愿老死电脑间，不愿鞠躬老板前；
//                  奔驰宝马贵者趣，公交自行程序员。
//                  别人笑我忒疯癫，我笑自己命太贱；
//                  不见满街漂亮妹，哪个归得程序员？
-->
<head>
    <!--[if lte IE 9]>
<meta http-equiv="refresh" content="0;url=http://yoursite.com/warn.html">
<![endif]-->
<meta charset="utf-8">

<meta http-equiv="X-UA-Compatible" content="IE=Edge">
<meta name="renderer" content="webkit">
<meta name="viewport" content="width=device-width, initial-scale=1.0,user-scalable=no">
<meta http-equiv="mobile-agent" content="format=html5; url=http://yoursite.com">
<meta name="author" content="John Doe">
<link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
<link rel="stylesheet" href="/css/SimpleStyle.min.css">

<link rel="shortcut icon" href="/images/favicon.png">


<title>数据库开发规范 - Hexo</title>

<meta name="keywords" content="">

<meta name="description " content="">
</head>
<body>
<div id="nav">
    <nav class="nav-menu">
        <a class="site-name current" href="/" title="说">说</a>
        <a class="site-index current" href="/"><i class="fa fa-home"></i><span>Home</span></a>
        <a href="/archives" title="Archives"><i class="fa fa-archives"></i><span>Archives</span></a>
        <a href="/tags" title="Tags"><i class="fa fa-tags"></i><span>Tags</span></a>
        <!-- custom single page of menus -->
        
        
        <a href="/cross_fire" title="穿越火线">
            <i class="fa fa-wifi"></i>
            <span>穿越火线</span>
        </a>
        
        
        <a href="/help" title="急救中心">
            <i class="fa fa-question-circle"></i>
            <span>急救中心</span>
        </a>
        
    </nav>
</div>

<div class="nav-user">
    <a class="btn-search" href="#"><i class="fa fa-search"></i></a>
    <a class="btn-read-mode" href="#"><i class="fa fa-sun-o"></i></a>
    <a class="btn-weixin-mp" href="javascript:"><i class="fa fa-weixin"></i></a>
</div>
<div id="wrapper" class="clearfix">
    <div id="body">
        <div class="main" id="main">
            <div id="cover">
    <div class="cover-img"></div>
    <div class="cover-info">
        
        <h1 class="cover-siteName">说IT</h1>
        <h3 class="cover-siteTitle">聊技术，谈情怀</h3>
        <p class="cover-siteDesc">一个关注技术与人文的IT博客</p>
        <div class="cover-sns">
            
            <div class="btn btn-telegram">
                <a href="http://t.me/codeist" target="_blank" title="telegram" ref="friend">
                    <i class="fa fa-telegram"></i>
                </a>
            </div>
            
            <div class="btn btn-instagram">
                <a href="https://www.instagram.com/coder.thomas/" target="_blank" title="instagram" ref="friend">
                    <i class="fa fa-instagram"></i>
                </a>
            </div>
            
            <div class="btn btn-twitter">
                <a href="https://twitter.com/tangkunyin" target="_blank" title="twitter" ref="friend">
                    <i class="fa fa-twitter"></i>
                </a>
            </div>
            
            <div class="btn btn-github">
                <a href="https://github.com/tangkunyin" target="_blank" title="github" ref="friend">
                    <i class="fa fa-github"></i>
                </a>
            </div>
            
        </div>
    </div>
</div>
            <div class="page-title">
    <ul>
        <li><a href="/">最新</a></li>
        
        
        
        <li class="page-search">
    <form id="search" class="search-form">
        <label for="s" class="sr-only">Input Search key Words Here</label>
        <input class="search-field" type="text" name="s" class="text" placeholder="Input Search key Words Here" />
        <button type="submit" class="search-form-submit" title="Search"><i class="fa fa-search"></i></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
</li>

    </ul>
</div>
<div class="main-inner">
    <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
        <div class="post-header">
            <div class="post-author clearfix">
                <a class="avatar fleft" href="" target="_blank">
                    <img width="48" src="" alt="avatar"/>
                </a>
                <p><span class="label">作者</span>
                    <a href="" target="_blank"></a>
                    <span title="最后编辑于2017-10-19">2017-10-19</span>
                </p>
                <p></p>
            </div>
            <h2 class="post-title">数据库开发规范</h2>
            <div class="post-meta">
                本文总共9578个字 | 您是第<span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>位看到它们的小伙伴
            </div>
        </div>
        <div class="post-content markdown-body">
            <p>[TOC]</p>
<h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><blockquote>
<p>数据库的所有表(Table)、视图(View)、索引(Index)、触发器(Trigger)、函数(Function)和存储过程(Store Procedure)均应遵循以下命名规范。</p>
</blockquote>
<ul>
<li>命名只能由小写字母和数字构成，并且只能是以小写字母打头</li>
<li>命名应采用能够准确反映其中文含义的英文单词或英文单词缩写构成，避免出现英文单词和汉语拼音混用的局面</li>
<li>命名长度不可以超过25个字符（表名尽量保持在20个字符的长度，然后再其上建立索引、主键、触发器等等的时候，便于加扩展信息）。名称的各部分之间以”_”(下划线)连接</li>
<li>字段如有相同定义，应该用相同命名</li>
<li>命名应避免用关键字</li>
</ul>
<h5 id="实体命名"><a href="#实体命名" class="headerlink" title="实体命名"></a>实体命名</h5><blockquote>
<p>实体(包括库表、视图、函数和索引等)命名结构如下：<br><code>prefix[_module]_body[_suffix]</code></p>
<p> <code>&lt;prefix&gt;</code>为前缀名，表示数据库对象的类型<br><code>&lt;module&gt;</code>为模块名，按应用模块进行分类，为可选项<br><code>&lt;body&gt;</code>为主体名，应该能够清楚地说明对象的含义<br><code>&lt;suffix&gt;</code>是后缀名，提供特效的含义，比如在该对象需分表存放时使用，如按月分开 存放的表，为可选项。</p>
</blockquote>
<h6 id="前缀命名"><a href="#前缀命名" class="headerlink" title="前缀命名"></a>前缀命名</h6><table>
<thead>
<tr>
<th style="text-align:center">前缀</th>
<th style="text-align:left">数据库对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">t</td>
<td style="text-align:left">表(Table)</td>
</tr>
<tr>
<td style="text-align:center">v</td>
<td style="text-align:left">视图(View)</td>
</tr>
<tr>
<td style="text-align:center">tri</td>
<td style="text-align:left">触发器(Trigger)</td>
</tr>
<tr>
<td style="text-align:center">p</td>
<td style="text-align:left">存储过程(Procedure)</td>
</tr>
<tr>
<td style="text-align:center">tt</td>
<td style="text-align:left">临时表(Temporary Table)</td>
</tr>
<tr>
<td style="text-align:center">idx</td>
<td style="text-align:left">索引(Index)</td>
</tr>
<tr>
<td style="text-align:center">uk</td>
<td style="text-align:left">唯一索引（Unique Index）</td>
</tr>
<tr>
<td style="text-align:center">pk</td>
<td style="text-align:left">主键(Primary Key)</td>
</tr>
<tr>
<td style="text-align:center">fk</td>
<td style="text-align:left">外键(Foreign Key)</td>
</tr>
<tr>
<td style="text-align:center">f</td>
<td style="text-align:left">函数（Function）</td>
</tr>
</tbody>
</table>
<h6 id="后缀命名"><a href="#后缀命名" class="headerlink" title="后缀命名"></a>后缀命名</h6><table>
<thead>
<tr>
<th style="text-align:center">后缀</th>
<th style="text-align:left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">_his</td>
<td style="text-align:left">历史表</td>
</tr>
<tr>
<td style="text-align:center">_log</td>
<td style="text-align:left">流水表</td>
</tr>
<tr>
<td style="text-align:center">_map</td>
<td style="text-align:left">对照表</td>
</tr>
<tr>
<td style="text-align:center">_rel</td>
<td style="text-align:left">关系表</td>
</tr>
<tr>
<td style="text-align:center">_yyyymmdd</td>
<td style="text-align:left">因数据量庞大，需按日分开存放的表</td>
</tr>
<tr>
<td style="text-align:center">_yyyymm</td>
<td style="text-align:left">因数据量庞大，需按月分开存放的表</td>
</tr>
</tbody>
</table>
<h5 id="字段命名"><a href="#字段命名" class="headerlink" title="字段命名"></a>字段命名</h5><blockquote>
<p>字段命名结构如下:<br><code>prefix_body[_suffix]</code></p>
<p> <code>&lt;prefix&gt;</code>为前缀名<br><code>&lt;body&gt;</code>为主体名，应该能够清楚地说明对象的含义<br><code>&lt;suffix&gt;</code>是后缀名，提供特效的含义，为可选项。</p>
</blockquote>
<h6 id="后缀命名-1"><a href="#后缀命名-1" class="headerlink" title="后缀命名"></a>后缀命名</h6><blockquote>
<p>以下是一些特别的后缀，代表了这个字段特效的含义。在其他的情况，应避免使用以下的后缀。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">后缀</th>
<th style="text-align:left">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">_desc</td>
<td style="text-align:left">参数表内的描叙字段,一般来讲是VARCHAR(255)</td>
</tr>
<tr>
<td style="text-align:center">_flag</td>
<td style="text-align:left">只可能是True或False的字段,一般来讲是TINYINT(1)</td>
</tr>
<tr>
<td style="text-align:center">_id</td>
<td style="text-align:left">标识字段，一般来讲是INT（11）</td>
</tr>
<tr>
<td style="text-align:center">_type</td>
<td style="text-align:left">类型字段，一般来讲是CHAR(1)</td>
</tr>
</tbody>
</table>
<h5 id="库名、表名、字段名禁止超过32个字符，需见名知意"><a href="#库名、表名、字段名禁止超过32个字符，需见名知意" class="headerlink" title="库名、表名、字段名禁止超过32个字符，需见名知意"></a>库名、表名、字段名禁止超过32个字符，需见名知意</h5><ul>
<li>库名、表名、字段名支持最多64个字符，但为了统一规范、易于辨识以及减少传输量，禁止超过32个字符</li>
</ul>
<h5 id="临时库、表名须以tmp加日期为后缀"><a href="#临时库、表名须以tmp加日期为后缀" class="headerlink" title="临时库、表名须以tmp加日期为后缀"></a>临时库、表名须以tmp加日期为后缀</h5><ul>
<li>如 t_crm_relation_tmp0425。备份表也类似，形如 _bak20160425</li>
</ul>
<h4 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h4><ul>
<li>一般来说，在保证正确性的前提下，尽量使用最小的数据类型来存储和表示数据。</li>
<li>小的数据类型一般比大的更快，因为小的数据类型占用的磁盘空间，内存和cup缓存都相对小，需要的cpu处理也要相对少。</li>
<li>这个原则很重要，但是设计的时候也不要低估需要存储的数据的数据范围。</li>
<li>简单的数据类型需要的cup处理周期更少，比如：对整数的处理比字符串处理更容易，因为字符集和排序规则使得字符串比较复杂化了。</li>
<li>两个典型例子是：使用mysql的内嵌数据类型来存储日期和时间而不是字符串，使用整数存储Ip地址而不是字符串。 </li>
</ul>
<h5 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h5><ul>
<li>非万不得已不要使用DOUBLE，不仅仅只是存储长度的问题，同时还会存在精确性的问题。使用Decimal 代替float/double。</li>
<li>固定精度的小数，也不建议使用DECIMAL，建议乘以固定倍数转换成整数存储，可以大大节省存储空间，且不会带来任何附加维护成本。</li>
<li>对于整数的存储，在数据量较大的情况下，建议区分开<code>TINYINT/INT/BIGINT</code>的选择，因为三者所占用的存储空间也有很大的差别，能确定不会使用负数的字段，建议添加unsigned定义。  </li>
</ul>
<h5 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h5><ul>
<li>非万不得已不要使用 TEXT 数据类型，其处理方式决定了他的性能要低于char或varchar类型的处理。</li>
<li>定长字段，建议使用 CHAR 类型，不定长字段尽量使用 VARCHAR，且仅仅设定适当的最大长度，而不是非常随意的给一个很大的最大长度限定，因为不同的长度范围，MySQL也会有不一样的存储处理。</li>
</ul>
<h5 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h5><ul>
<li>尽量使用TIMESTAMP类型，因为其存储空间只需要 DATETIME 类型的一半。2032年</li>
<li>对于只需要精确到某一天的数据类型，建议使用DATE类型，因为他的存储空间只需要3个字节，比TIMESTAMP还少。</li>
<li>不建议通过INT类型类存储一个unix timestamp 的值，因为这太不直观，会给维护带来不必要的麻烦，同时还不会带来任何好处。</li>
</ul>
<h5 id="ENUM-amp-SET"><a href="#ENUM-amp-SET" class="headerlink" title="ENUM&amp;SET"></a>ENUM&amp;SET</h5><ul>
<li>使用tinyint来代替 enum和boolean</li>
<li>ENUM类型在需要修改或增加枚举值时，需要在线DDL，成本较高</li>
<li>ENUM列值如果含有数字类型，可能会引起默认值混淆</li>
<li>tinyint使用1个字节，一般用于status,type,flag的列</li>
<li>对于状态字段，可以尝试使用 ENUM 来存放，因为可以极大的降低存储空间。</li>
<li>如果是存放可预先定义的属性数据，可以尝试使用SET类型，即使存在多种属性，同样可以游刃有余，同时还可以节省不小的存储空间。</li>
</ul>
<h5 id="LOB-类型"><a href="#LOB-类型" class="headerlink" title="LOB 类型"></a>LOB 类型</h5><ul>
<li>强烈反对在数据库中存放 LOB 类型数据</li>
</ul>
<h5 id="同一意义的字段定义必须相同"><a href="#同一意义的字段定义必须相同" class="headerlink" title="同一意义的字段定义必须相同"></a>同一意义的字段定义必须相同</h5><ul>
<li>比如不同表中都有 f_user_id 字段，那么它的类型、字段长度要设计成一样</li>
</ul>
<h4 id="表结构设计"><a href="#表结构设计" class="headerlink" title="表结构设计"></a>表结构设计</h4><ul>
<li>适度冗余。不需要一定遵守范式理论，适度的冗余，让Query尽量减少Join</li>
<li>尽量使用NOT NULL。尽可能把字段定义成NOT NULL，许多表包含一些字段允许空的字段，即使应用需求不需要存储NULL的数据，因为允许字段为NULL是缺省的。允许NULL的字段会占用掉更多的存储空间和花掉更多的cpu处理，当为一个可为空的字段建立索引时，需要为每项分配一个额外的字节。即使遇到不需要存储值到某个字段，也应当考虑不使用NULL，而是考虑使用0，一个特殊值或者空串来代替。</li>
<li>杜绝直接 SELECT * 读取全部字段<br><br>即使需要所有字段，减少网络带宽消耗，能有效利用覆盖索引，表结构变更对程序基本无影响</li>
<li>能确定返回结果只有一条时，使用 limit 1<br><br>在保证数据不会有误的前提下，能确定结果集数量时，多使用limit，尽快的返回结果。</li>
</ul>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><ul>
<li>唯一确定一条记录的一个字段或多个字段要建立主键或者唯一索引，不能唯一确定一条记录，为了提高查询效率建普通索引</li>
<li>对于取值不能重复，经常作为查询条件的字段，应该建唯一索引(主键默认唯一索引)，并且将查询条件中该字段的条件置于第一个位置。没有必要再建立与该字段有关的联合索引。</li>
<li>对于经常查询的字段，其值不唯一，也应该考虑建立普通索引，查询语句中该字段条件置于第一个位置，对联合索引处理的方法同样。</li>
<li>需要联合索引(或联合主键)的数据库要注意索引的顺序。SQL语句中的匹配条件也要跟索引的顺序保持一致。</li>
</ul>
<h4 id="基础规范"><a href="#基础规范" class="headerlink" title="基础规范"></a>基础规范</h4><h5 id="使用Innodb存储引擎"><a href="#使用Innodb存储引擎" class="headerlink" title="使用Innodb存储引擎"></a>使用Innodb存储引擎</h5><ul>
<li>5.5版本开始mysql默认存储引擎就是InnoDB，5.7版本开始，系统表都放弃MyISAM了。</li>
<li>表字符集统一使用UTF8</li>
<li>UTF8字符集存储汉字占用3个字节，存储英文字符占用一个字节</li>
<li>校对字符集使用默认的 utf8_general_ci</li>
<li>连接的客户端也使用utf8，建立连接时指定charset或SET NAMES UTF8;。（对于已经在项目中长期使用latin1的，救不了了）</li>
<li>如果遇到EMOJ等表情符号的存储需求，可申请使用UTF8MB4字符集</li>
</ul>
<h5 id="所有表都要添加注释"><a href="#所有表都要添加注释" class="headerlink" title="所有表都要添加注释"></a>所有表都要添加注释</h5><ul>
<li>尽量给字段也添加注释</li>
<li>类status型需指明主要值的含义，如”0-离线，1-在线”</li>
</ul>
<h5 id="控制单表字段数量"><a href="#控制单表字段数量" class="headerlink" title="控制单表字段数量"></a>控制单表字段数量</h5><ul>
<li>单表字段数上限30左右，再多的话考虑垂直分表，一是冷热数据分离，二是大字段分离，三是常在一起做条件和返回列的不分离。</li>
<li>表字段控制少而精，可以提高IO效率，内存缓存更多有效数据，从而提高响应速度和并发能力，后续 alter table 也更快。</li>
</ul>
<h5 id="所有表都必须要显式指定主键"><a href="#所有表都必须要显式指定主键" class="headerlink" title="所有表都必须要显式指定主键"></a>所有表都必须要显式指定主键</h5><ul>
<li>主键尽量采用自增方式，InnoDB表实际是一棵索引组织表，顺序存储可以提高存取效率，充分利用磁盘空间。还有对一些复杂查询可能需要自连接来优化时需要用到。</li>
<li>需要全局唯一主键时，使用外部发号器ticket server（建设中）</li>
<li>如果没有主键或唯一索引，update/delete是通过所有字段来定位操作的行，相当于每行就是一次全表扫描</li>
<li>少数情况可以使用联合唯一主键，需与DBA协商</li>
</ul>
<h5 id="不强制使用外键参考"><a href="#不强制使用外键参考" class="headerlink" title="不强制使用外键参考"></a>不强制使用外键参考</h5><ul>
<li>即使2个表的字段有明确的外键参考关系，也不使用 FOREIGN KEY ，因为新纪录会去主键表做校验，影响性能。</li>
</ul>
<h5 id="适度使用存储过程、视图，禁止使用触发器、事件"><a href="#适度使用存储过程、视图，禁止使用触发器、事件" class="headerlink" title="适度使用存储过程、视图，禁止使用触发器、事件"></a>适度使用存储过程、视图，禁止使用触发器、事件</h5><ul>
<li>存储过程（procedure）虽然可以简化业务端代码，在传统企业写复杂逻辑时可能会用到，而在互联网企业变更是很频繁的，在分库分表的情况下要升级一个存储过程相当麻烦。又因为它是不记录log的，所以也不方便debug性能问题。如果使用过程，一定考虑如果执行失败的情况。</li>
<li>使用视图一定程度上也是为了降低代码里SQL的复杂度，但有时候为了视图的通用性会损失性能（比如返回不必要的字段）。</li>
<li>触发器（trigger）也是同样，但也不应该通过它去约束数据的强一致性，mysql只支持“基于行的触发”，也就是说，触发器始终是针对一条记录的，而不是针对整个sql语句的，如果变更的数据集非常大的话，效率会很低。掩盖一条sql背后的工作，一旦出现问题将是灾难性的，但又很难快速分析和定位。再者需要ddl时无法使用pt-osc工具。放在transaction执行。</li>
<li>事件（event）也是一种偷懒的表现，目前已经遇到数次由于定时任务执行失败影响业务的情况，而且mysql无法对它做失败预警。建立专门的 job scheduler 平台。</li>
</ul>
<h5 id="单表数据量控制在5000w以内"><a href="#单表数据量控制在5000w以内" class="headerlink" title="单表数据量控制在5000w以内"></a>单表数据量控制在5000w以内</h5><h5 id="数据库中不允许存储明文密码"><a href="#数据库中不允许存储明文密码" class="headerlink" title="数据库中不允许存储明文密码"></a>数据库中不允许存储明文密码</h5><h4 id="索引规范"><a href="#索引规范" class="headerlink" title="索引规范"></a>索引规范</h4><h5 id="任何新的select-update-delete上线，都要先explain，看索引使用情况"><a href="#任何新的select-update-delete上线，都要先explain，看索引使用情况" class="headerlink" title="任何新的select,update,delete上线，都要先explain，看索引使用情况"></a>任何新的select,update,delete上线，都要先explain，看索引使用情况</h5><ul>
<li>尽量避免extra列出现：Using File Sort，Using Temporary，rows超过1000的要谨慎上线。<br>explain解读</li>
<li>type：ALL, index, range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）</li>
<li>possible_keys：指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用</li>
<li>key：表示MySQL实际决定使用的键（索引）</li>
<li>如果没有选择索引，键是NULL。要想强制MySQL使用或忽视possible_keys列中的索引，在查询中使用FORCE INDEX、USE INDEX或者IGNORE INDEX</li>
<li>ref：表示选择 key 列上的索引，哪些列或常量被用于查找索引列上的值</li>
<li>rows：根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</li>
<li>Extra</li>
<li>Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询</li>
<li>Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”</li>
</ul>
<h5 id="索引个数限制"><a href="#索引个数限制" class="headerlink" title="索引个数限制"></a>索引个数限制</h5><ul>
<li>索引是双刃剑，会增加维护负担，增大IO压力，索引占用空间是成倍增加的</li>
<li>单张表的索引数量控制在5个以内，或不超过表字段个数的20%。若单张表多个字段在查询需求上都要单独用到索引，需要经过DBA评估。</li>
</ul>
<h5 id="避免冗余索引"><a href="#避免冗余索引" class="headerlink" title="避免冗余索引"></a>避免冗余索引</h5><ul>
<li>InnoDB表是一棵索引组织表，主键是和数据放在一起的聚集索引，普通索引最终指向的是主键地址，所以把主键做最后一列是多余的。如f_crm_id作为主键，联合索引(f_user_id,f_crm_id)上的f_crm_id就完全多余</li>
<li>(a,b,c)、(a,b)，后者为冗余索引。可以利用前缀索引来达到加速目的，减轻维护负担</li>
</ul>
<h5 id="没有特殊要求，使用自增id作为主键"><a href="#没有特殊要求，使用自增id作为主键" class="headerlink" title="没有特殊要求，使用自增id作为主键"></a>没有特殊要求，使用自增id作为主键</h5><ul>
<li>主键是一种聚集索引，顺序写入。组合唯一索引作为主键的话，是随机写入，适合写少读多的表</li>
<li>主键不允许更新</li>
</ul>
<h5 id="索引尽量建在选择性高的列上"><a href="#索引尽量建在选择性高的列上" class="headerlink" title="索引尽量建在选择性高的列上"></a>索引尽量建在选择性高的列上</h5><ul>
<li>不在低基数列上建立索引，例如性别、类型。但有一种情况，idx_feedbackid_type (f_feedback_id,f_type)，如果经常用 f_type=1 比较，而且能过滤掉90%行，那这个组合索引就值得创建。有时候同样的查询语句，由于条件取值不同导致使用不同的索引，也是这个道理。</li>
<li>索引选择性计算方法（基数 ÷ 数据行数）</li>
<li>Selectivity = Cardinality / Total Rows = select count(distinct col1)/count(*) from tbname，越接近1说明col1上使用索引的过滤效果越好</li>
<li>走索引扫描行数超过30%时，改全表扫描</li>
</ul>
<h5 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h5><ul>
<li>mysql使用联合索引时，从左向右匹配，遇到断开或者范围查询时，无法用到后续的索引列</li>
<li>比如索引idx_c1_c2_c3 (c1,c2,c3)，相当于创建了(c1)、(c1,c2)、(c1,c2,c3)三个索引，where条件包含上面三种情况的字段比较则可以用到索引，但像 where c1=a and c3=c 只能用到c1列的索引，像 c2=b and c3=c等情况就完全用不到这个索引</li>
<li>遇到范围查询(&gt;、&lt;、between、like)也会停止索引匹配，比如 c1=a and c2 &gt; 2 and c3=c，只有c1,c2列上的比较能用到索引，(c1,c2,c3)排列的索引才可能会都用上</li>
<li>where条件里面字段的顺序与索引顺序无关，mysql优化器会自动调整顺序</li>
</ul>
<h5 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h5><ul>
<li>对超过30个字符长度的列创建索引时，考虑使用前缀索引，如 idx_cs_guid2 (f_cs_guid(26))表示截取前26个字符做索引，既可以提高查找效率，也可以节省空间</li>
<li>前缀索引也有它的缺点是，如果在该列上 ORDER BY 或 GROUP BY 时无法使用索引，也不能把它们用作覆盖索引(Covering Index)</li>
<li>如果在varbinary或blob这种以二进制存储的列上建立前缀索引，要考虑字符集，括号里表示的是字节数</li>
</ul>
<h5 id="合理使用覆盖索引减少IO"><a href="#合理使用覆盖索引减少IO" class="headerlink" title="合理使用覆盖索引减少IO"></a>合理使用覆盖索引减少IO</h5><ul>
<li>INNODB存储引擎中，secondary index(非主键索引，又称为辅助索引、二级索引)没有直接存储行地址，而是存储主键值。</li>
<li>如果用户需要查询secondary index中所不包含的数据列，则需要先通过secondary index查找到主键值，然后再通过主键查询到其他数据列，因此需要查询两次。覆盖索引则可以在一个索引中获取所有需要的数据列，从而避免回表进行二次查找，节省IO因此效率较高。</li>
<li>例如SELECT email，uid FROM user_email WHERE uid=xx，如果uid不是主键，适当时候可以将索引添加为index(uid，email)，以获得性能提升。</li>
</ul>
<h5 id="尽量不要在频繁更新的列上创建索引"><a href="#尽量不要在频繁更新的列上创建索引" class="headerlink" title="尽量不要在频繁更新的列上创建索引"></a>尽量不要在频繁更新的列上创建索引</h5><ul>
<li>如不在定义了 ON UPDATE CURRENT_STAMP 的列上创建索引，维护成本太高（好在mysql有insert buffer，会合并索引的插入）</li>
</ul>
<h4 id="SQL设计"><a href="#SQL设计" class="headerlink" title="SQL设计"></a>SQL设计</h4><h5 id="杜绝直接-SELECT-读取全部字段"><a href="#杜绝直接-SELECT-读取全部字段" class="headerlink" title="杜绝直接 SELECT * 读取全部字段"></a>杜绝直接 SELECT * 读取全部字段</h5><ul>
<li>即使需要所有字段，减少网络带宽消耗，能有效利用覆盖索引，表结构变更对程序基本无影响</li>
</ul>
<h5 id="能确定返回结果只有一条时，使用-limit-1"><a href="#能确定返回结果只有一条时，使用-limit-1" class="headerlink" title="能确定返回结果只有一条时，使用 limit 1"></a>能确定返回结果只有一条时，使用 limit 1</h5><ul>
<li>在保证数据不会有误的前提下，能确定结果集数量时，多使用limit，尽快的返回结果。</li>
</ul>
<h5 id="小心隐式类型转换"><a href="#小心隐式类型转换" class="headerlink" title="小心隐式类型转换"></a>小心隐式类型转换</h5><p>转换规则<br>a. 两个参数至少有一个是 NULL 时，比较的结果也是 NULL，例外是使用 &lt;=&gt; 对两个 NULL 做比较时会返回 1，这两种情况都不需要做类型转换<br>b. 两个参数都是字符串，会按照字符串来比较，不做类型转换<br>c. 两个参数都是整数，按照整数来比较，不做类型转换<br>d. 十六进制的值和非数字做比较时，会被当做二进制串<br>e. 有一个参数是 TIMESTAMP 或 DATETIME，并且另外一个参数是常量，常量会被转换为 timestamp<br>f. 有一个参数是 decimal 类型，如果另外一个参数是 decimal 或者整数，会将整数转换为 decimal 后进行比较，如果另外一个参数是浮点数，则会把 decimal 转换为浮点数进行比较<br>g. 所有其他情况下，两个参数都会被转换为浮点数再进行比较。</p>
<ul>
<li>如果一个索引建立在string类型上，如果这个字段和一个int类型的值比较，符合第 g 条。如f_phone定义的类型是varchar，但where使用f_phone in (098890)，两个参数都会被当成成浮点型。发生这个隐式转换并不是最糟的，最糟的是string转换后的float，mysql无法使用索引，这才导致了性能问题。如果是 f_user_id = ‘1234567’ 的情况，符合第 b 条,直接把数字当字符串比较。</li>
</ul>
<h5 id="禁止在where条件列上使用函数"><a href="#禁止在where条件列上使用函数" class="headerlink" title="禁止在where条件列上使用函数"></a>禁止在where条件列上使用函数</h5><ul>
<li>会导致索引失效，如lower(email)，f_qq % 4。可放到右边的常量上计算</li>
<li>返回小结果集不是很大的情况下，可以对返回列使用函数，简化程序开发</li>
</ul>
<h5 id="使用like模糊匹配，-不要放首位"><a href="#使用like模糊匹配，-不要放首位" class="headerlink" title="使用like模糊匹配，%不要放首位"></a>使用like模糊匹配，%不要放首位</h5><ul>
<li>会导致索引失效，有这种搜索需求是，考虑其它方案，如sphinx全文搜索</li>
</ul>
<h5 id="涉及到复杂sql时，务必先参考已有索引设计，先explain"><a href="#涉及到复杂sql时，务必先参考已有索引设计，先explain" class="headerlink" title="涉及到复杂sql时，务必先参考已有索引设计，先explain"></a>涉及到复杂sql时，务必先参考已有索引设计，先explain</h5><ul>
<li>简单SQL拆分，不以代码处理复杂为由。</li>
<li>比如 OR 条件： f_phone=’10000’ or f_mobile=’10000’，两个字段各自有索引，但只能用到其中一个。可以拆分成2个sql，或者union all。</li>
<li>先explain的好处是可以为了利用索引，增加更多查询限制条件</li>
</ul>
<h5 id="使用join时，where条件尽量使用充分利用同一表上的索引"><a href="#使用join时，where条件尽量使用充分利用同一表上的索引" class="headerlink" title="使用join时，where条件尽量使用充分利用同一表上的索引"></a>使用join时，where条件尽量使用充分利用同一表上的索引</h5><ul>
<li>如 select t1.a,t2.b * from t1,t2 and t1.a=t2.a and t1.b=123 and t2.c= 4 ，如果t1.c与t2.c字段相同，那么t1上的索引(b,c)就只用到b了。此时如果把where条件中的t2.c=4改成t1.c=4，那么可以用到完整的索引</li>
<li>这种情况可能会在字段冗余设计（反范式）时出现</li>
<li>正确选取inner join和left join</li>
</ul>
<h5 id="少用子查询，改用join"><a href="#少用子查询，改用join" class="headerlink" title="少用子查询，改用join"></a>少用子查询，改用join</h5><ul>
<li>小于5.6版本时，子查询效率很低，不像Oracle那样先计算子查询后外层查询。5.6版本开始得到优化</li>
</ul>
<h5 id="考虑使用union-all，少使用union，注意考虑去重"><a href="#考虑使用union-all，少使用union，注意考虑去重" class="headerlink" title="考虑使用union all，少使用union，注意考虑去重"></a>考虑使用union all，少使用union，注意考虑去重</h5><ul>
<li>union all不去重，而少了排序操作，速度相对比union要快，如果没有去重的需求，优先使用union all</li>
<li>如果UNION结果中有使用limit，在2个子SQL可能有许多返回值的情况下，各自加上limit。如果还有order by，请找DBA。</li>
</ul>
<h5 id="IN的内容尽量不超过200个"><a href="#IN的内容尽量不超过200个" class="headerlink" title="IN的内容尽量不超过200个"></a>IN的内容尽量不超过200个</h5><ul>
<li>超过500个值使用批量的方式，否则一次执行会影响数据库的并发能力，因为单SQL只能且一直占用单CPU，而且可能导致主从复制延迟</li>
</ul>
<h5 id="拒绝大事务"><a href="#拒绝大事务" class="headerlink" title="拒绝大事务"></a>拒绝大事务</h5><ul>
<li>比如在一个事务里进行多个select，多个update，如果是高频事务，会严重影响MySQL并发能力，因为事务持有的锁等资源只在事务rollback/commit时才能释放。但同时也要权衡数据写入的一致性。</li>
</ul>
<h5 id="避免使用is-null-is-not-null这样的比较"><a href="#避免使用is-null-is-not-null这样的比较" class="headerlink" title="避免使用is null, is not null这样的比较"></a>避免使用is null, is not null这样的比较</h5><h5 id="order-by-limit"><a href="#order-by-limit" class="headerlink" title="order by .. limit"></a>order by .. limit</h5><ul>
<li>这种查询更多的是通过索引去优化，但order by的字段有讲究，比如主键id与f_time都是顺序递增，那就可以考虑order by id而非 f_time 。</li>
</ul>
<h5 id="c1-lt-a-order-by-c2"><a href="#c1-lt-a-order-by-c2" class="headerlink" title="c1 &lt; a order by c2"></a>c1 &lt; a order by c2</h5><ul>
<li>与上面不同的是，order by之前有个范围查询，由前面的内容可知，用不到类似(c1,c2)的索引，但是可以利用(c2,c1)索引。另外还可以改写成join的方式实现。</li>
</ul>
<h5 id="分页优化"><a href="#分页优化" class="headerlink" title="分页优化"></a>分页优化</h5><ul>
<li>建议使用合理的分页方式以提高分页效率，大页情况下不使用跳跃式分页</li>
<li>假如有类似下面分页语句:</li>
<li>SELECT FROM table1 ORDER BY ftime DESC LIMIT 10000,10;</li>
<li>这种分页方式会导致大量的io，因为MySQL使用的是提前读取策略。</li>
<li>推荐分页方式：</li>
<li>SELECT FROM table1 WHERE ftime &lt; last_time ORDER BY ftime DESC LIMIT 10</li>
<li>即传入上一次分页的界值</li>
<li>SELECT * FROM table as t1 inner JOIN (SELECT id FROM table ORDER BY time LIMIT 10000，10) as t2 ON t1.id=t2.id</li>
</ul>
<h5 id="count计数"><a href="#count计数" class="headerlink" title="count计数"></a>count计数</h5><ul>
<li>首先count()、count(1)、count(col1)是有区别的，count()表示整个结果集有多少条记录，count(1)表示结果集里以primary key统计数量，绝大多数情况下count()与count(1)效果一样的，但count(col1)表示的是结果集里 col1 列 NOT null 的记录数。优先采用count()</li>
<li>大数据量count是消耗资源的操作，甚至会拖慢整个库，查询性能问题无法解决的，应从产品设计上进行重构。例如当频繁需要count的查询，考虑使用汇总表</li>
<li>遇到distinct的情况，group by方式可能效率更高。</li>
</ul>
<h5 id="delete-update语句改成select再explain"><a href="#delete-update语句改成select再explain" class="headerlink" title="delete,update语句改成select再explain"></a>delete,update语句改成select再explain</h5><ul>
<li>select最多导致数据库慢，写操作才是锁表的罪魁祸首</li>
</ul>
<h5 id="减少与数据库交互的次数，尽量采用批量SQL语句"><a href="#减少与数据库交互的次数，尽量采用批量SQL语句" class="headerlink" title="减少与数据库交互的次数，尽量采用批量SQL语句"></a>减少与数据库交互的次数，尽量采用批量SQL语句</h5><ul>
<li>INSERT … ON DUPLICATE KEY UPDATE …，插入行后会导致在一个UNIQUE索引或PRIMARY KEY中出现重复值，则执行旧行UPDATE，如果不重复则直接插入，影响1行。</li>
<li>REPLACE INTO类似，但它是冲突时删除旧行。INSERT IGNORE相反，保留旧行，丢弃要插入的新行。</li>
<li>INSERT INTO VALUES(),(),()，合并插入。</li>
</ul>
<h5 id="杜绝危险SQL"><a href="#杜绝危险SQL" class="headerlink" title="杜绝危险SQL"></a>杜绝危险SQL</h5><ul>
<li>去掉where 1=1 这样无意义或恒真的条件，如果遇到update/delete或遭到sql注入就恐怖了</li>
<li>SQL中不允许出现DDL语句。一般不给予create/alter这类权限</li>
</ul>
<h4 id="行为规范"><a href="#行为规范" class="headerlink" title="行为规范"></a>行为规范</h4><ul>
<li>不允许在DBA不知情的情况下导现网数据</li>
<li>大批量更新，如修复数据，避开高峰期，并通知DBA。直接执行sql的由运维或DBA同事操作</li>
<li>及时处理已下线业务的SQL</li>
<li>复杂sql上线审核</li>
<li>因为目前还没有SQL审查机制，复杂sql如多表join,count,group by，主动上报DBA评估。</li>
<li>重要项目的数据库方案选型和设计必须提前通知DBA参与</li>
</ul>

        </div>
        <div class="post-tool">
            <a class="btn-thumbs-up" href="javascript:void(0);" data-cid="52" title="95">
                <i class="fa fa-thumbs-up" aria-hidden="true"></i> 打赏
            </a>
        </div>
        
        <div class="post-tags">Tags：
            
        </div>
        
    </article>
    
    <p>本文内容仅作为作者个人兴趣与观点，不代表所在公司及团队的观点和决策。若有不恰当之处，望不吝赐教</p>
    
    
</div>
<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
        </div><!-- end #main-->
    </div><!-- end #body -->
    <footer class="footer">
    <div class="footer-inner">
        <p>
            <a href="/about"  title="About">About</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <!-- 自定义链接 -->
            <a href="/help" title="help" >急救中心</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/links" title="友情链接">友情链接</a>&nbsp;&nbsp<em>·</em>&nbsp;&nbsp
            <a href="/app" title="App下载">App下载</a>
        </p>
        <p>
            本站点采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>，已建立<a href="/timeline" id="siteBuildingTime"></a>天<br/>
            ©2017 基于<a href="http://hexo.io" target="_blank">Hexo</a>搭建
            ，主题&nbsp<a href="https://github.com/tangkunyin/hexo-theme-jsimple" target="_blank">JSimple</a>
            ，作者<a href="https://www.tangkunyin.com" target="_blank">唐先森</a>
            ，Hosted by <a href="https://pages.coding.me" style="font-weight: bold">Coding Pages</a>
        </p>
        
    </div>
</footer>
<script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>
<script src="/js/InsightSearch.js"></script>
<script src="/js/SimpleCore.js"></script>

</div>
<div class="fixed-btn">
    <a class="btn-gotop" href="javascript:"> <i class="fa fa-angle-up"></i></a>
</div>
<script>
    $(function () {
        SimpleCore.init({
            buildingTime: '08/20/2014',
            current: $('.post-tags').length > 0 ? 'post' : 'archive',
            wxMpImg: '/images/weixin-mp.png',
            donateImg: '/images/donate-qr.png',
        });
    });
</script>
</body>
</html>